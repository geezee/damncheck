<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>damncheck</title>
        </head><body>
        <h1>damncheck</h1>
        <!-- Generated by Ddoc from damncheck.d -->
DamnCheck - Property based testing library for D forked from dashcheck
<br><br>
<b>Authors:</b><br>
github.com/geezee

<br><br>
<b>Version:</b><br>
0.1

<br><br>
<b>License:</b><br>
MIT

<br><br>
<b>Forked:</b><br>
dashcheck - http://github.com/mcandre/dashcheck<br><br>

<dl><dt><big><a name="DamnStat"></a>alias <u>DamnStat</u> = std.typecons.Tuple!(bool, int, int, string).Tuple;
</big></dt>
<dd>The type to return after tests are completed
<br><br>
The first element (bool) is whether all the tests passed or not,
 the second (int) is the number of tests supposed to be run,
 the third (int) is the number of tests ran,
 and the last (string) is the representation of the failed test<br><br>

</dd>
<dt><big><a name="ARRAY_MAX_SIZE"></a>int <u>ARRAY_MAX_SIZE</u>;
</big></dt>
<dd>The maximum size an (associative) array can have when generating a random
 one.
<br><br>
<b>See Also:</b><br>
list, dict<br><br>

</dd>
<dt><big><a name="NUM_TESTS"></a>int <u>NUM_TESTS</u>;
</big></dt>
<dd>The default number of tests to run
<br><br>
<b>See Also:</b><br>
forAll<br><br>

</dd>
<dt><big><a name="oneOf"></a>auto <u>oneOf</u>(T...)(lazy T <i>generators</i>) if (<i>generators</i>.length &gt;= 2);
</big></dt>
<dd>A meta-generator that selects randomly a provided generator from its input
 and returs the value it returns. Requires at least 2 inputs.
<br><br>
<b>Params:</b><br>
<table><tr><td>T generators</td>
<td>A tuple of generators</td></tr>
</table><br>
<b>Returns:</b><br>
the value that a random generator from the input returns

<br><br>
<b>Example:</b><br>
<pre class="d_code"><u>oneOf</u>(generate!<font color=blue>float</font>(-1f,1f), generate!<font color=blue>float</font>(99f,100f)); <font color=green>// a random number in [-1,1]U[99,100]
</font><u>oneOf</u>(2, 4, 0, 5, 10); <font color=green>// a random number in {2, 4, 0, 5, 10}
</font></pre>
<br><br>

</dd>
<dt><big><a name="mapGenerate"></a>U <u>mapGenerate</u>(alias mapper, T, U = T)(lazy T <i>generator</i> = generate!T);
</big></dt>
<dd>A meta-generator that applies a map on a generator to transform it into another
 generator.
<br><br>
<b>Params:</b><br>
<table><tr><td>mapper</td>
<td>the mapping function to use. It needs to be callable on one value.</td></tr>
<tr><td>T generator</td>
<td>the generator function to use when mapping</td></tr>
</table><br>
<b>Returns:</b><br>
An element from the generator that is mapped to the domain of the mapper

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>mapGenerate</u>!(a =&gt; a % 2 == 0 ? a + 1 : a)(generate!<font color=blue>int</font>); <font color=green>// generate an odd int
</font><u>mapGenerate</u>!(a =&gt; a % 10, <font color=blue>int</font>); <font color=green>// generate a number betwen -10 and 10
</font></pre>
<br><br>

</dd>
<dt><big><a name="list"></a>T[] <u>list</u>(T, size_t N = ARRAY_MAX_SIZE)(lazy T <i>generator</i> = generate!T);
</big></dt>
<dd>A meta-generator that builds an array of random length whose elements are
 generated from the provided generator.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>the maximum size the array can have (inclusive), the default
                value is ARRAY_MAX_SIZE</td></tr>
<tr><td>T generator</td>
<td>the generator to use to build the array, the default value is
                generate!T</td></tr>
</table><br>
<b>Returns:</b><br>
An array contaning some elements generated from the provided generator

<br><br>
<b>Throws:</b><br>
Exception when the generate!T generator is used if T is not a suitable
    type for generate.

<br><br>
<b>See Also:</b><br>
generate, sample

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>list</u>!<font color=blue>int</font>; <font color=green>// generate a list of integers, [-12885020, .... 48124]
</font><u>list</u>!(<font color=blue>bool</font>,4); <font color=green>// generate a list that is at most 4 elements long, [true]
</font><u>list</u>!<font color=blue>int</font>(0); <font color=green>// generate an array of all 0s, [0, 0, ..., 0]
</font><u>list</u>!(<font color=blue>float</font>, 3)(generate!<font color=blue>float</font>(3, 5)); <font color=green>// [4.2852, 3.4924]
</font></pre>
<br><br>

</dd>
<dt><big><a name="dict"></a>T[U] <u>dict</u>(T, U, size_t N = ARRAY_MAX_SIZE)(lazy T <i>values</i> = generate!T, lazy U <i>keys</i> = generate!U);
</big></dt>
<dd>A meta-generator that builds an associative array whose length is random and
 whose keys and values are elements generated from the provided generators.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>the maximum length of the associative array (inclusive), the default
        is ARRAY_MAX_SIZE</td></tr>
<tr><td>T values</td>
<td>the generator to use to generate the values of the associative
             array, the default value is generate!T</td></tr>
<tr><td>U keys</td>
<td>the generator to use to generate the keys of the associative array,
           the default values is generate!U</td></tr>
</table><br>
<b>Returns:</b><br>
An associative array of random size and whose keys and values are generated
    from generators passed as arguments

<br><br>
<b>Throws:</b><br>
Exception if the key value and/or the value type force generate to throw
    an exception; i.e. when the types are not suitable for the generator

<br><br>
<b>See Also:</b><br>
generate

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>dict</u>!(<font color=blue>int</font>, <font color=blue>int</font>); <font color=green>// [-84: 92831, 8492: 4589284, -4892:-985717 ...]
</font><u>dict</u>!(<font color=blue>int</font>, <font color=blue>bool</font>); <font color=green>// [false: 21249894, true: -832194]
</font><u>dict</u>!(<font color=blue>int</font>, <font color=blue>bool</font>, 10000)(3); <font color=green>// [false: 3, true: 3]
</font></pre>
<br><br>

</dd>
<dt><big><a name="choose"></a>T <u>choose</u>(T)(T[] <i>array</i>);
</big></dt>
<dd>A generator that chooses randomly an element from a given array
<br><br>
<b>Params:</b><br>
<table><tr><td>T[] array</td>
<td>the array of elements to chose randomly from</td></tr>
</table><br>
<b>Returns:</b><br>
an element from the array that is chosen at random

<br><br>
<b>Throws:</b><br>
Exception if the input is of length 0

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>choose</u>([1, -1, 8, -8, 23]);
</pre>
<br><br>

</dd>
<dt><big><a name="generate"></a>T <u>generate</u>(T)(T <i>min</i> = T.init, T <i>max</i> = T.init);
</big></dt>
<dd>Generate some random values based on a type.
<br><br>
<b>Params:</b><br>
<table><tr><td>T min</td>
<td>only used for elements who have the init property and are not arrays.
         It is the smallest value an element can have (inclusive). The default
         is T.init which is then converted to T.min</td></tr>
<tr><td>T max</td>
<td>only used for elements who have the init property and are not arrays.
         It is the largest value an element can have (inclusive). The default
         is T.init which is then converted to T.max</td></tr>
</table><br>
<b>Returns:</b><br>
A random element of type T provided

<br><br>
<b>See Also:</b><br>
list, dict

<br><br>
<b>Throws:</b><br>
Exception when no generating function is available

<br><br>
<b>TODO:</b><br>
"Unwrap" a struct/class through the paramaters of their constructor and
   construct a random object through these types.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>generate</u>!<font color=blue>bool</font>; <font color=green>// true
</font><u>generate</u>!string; <font color=green>// "necxTT!30"
</font><u>generate</u>!(<font color=blue>int</font>[]); <font color=green>// will call list!int
</font><u>generate</u>!(<font color=blue>immutable</font> <font color=blue>int</font>[<font color=blue>char</font>[<font color=blue>immutable</font> <font color=blue>bool</font>]]);
<font color=green>// will call dict!(immutable int, char[immutable bool]);
</font>
<u>generate</u>!<font color=blue>int</font>(10); <font color=green>// 392874
</font><u>generate</u>!<font color=blue>float</font>(10f, 11f); <font color=green>// 10.7329
</font></pre>
<br><br>

</dd>
<dt><big><a name="sample"></a>T[] <u>sample</u>(T, const(int) N = 10)(lazy T <i>gen</i> = generate!T);
</big></dt>
<dd>Sampling some values that the generator produces. The <u>sample</u> function and the
 list function might seem very similar but besides the difference in the
 objective, this function returns exactly an array of size N while the list
 function returns a list that has at most size N.
<br><br>
<b>Params:</b><br>
<table><tr><td>T gen</td>
<td>the generator, defaults to generate!T where T is the generic type
         passed to the function</td></tr>
<tr><td>N</td>
<td>the number values to samples (default is 10)</td></tr>
</table><br>
<b>Returns:</b><br>
An array of size N containing samples from the generators

<br><br>
<b>Throws:</b><br>
Exception if the default generate!T generator is used with no suitable
   type.

<br><br>
<b>See Also:</b><br>
generate

<br><br>
<b>Example:</b><br>
<pre class="d_code"><u>sample</u>!<font color=blue>int</font>;
<font color=green>/+ [1541546906, -1397396910, 1173201093, 781288830, -10598603, -1822147006,
    1798781252, 950268125, -966182456, -275607635] +/</font>
<u>sample</u>!(<font color=blue>bool</font>, 2);
<font color=green>// [false, false]
</font><u>sample</u>(generate!<font color=blue>float</font>(-1f,1f));
<font color=green>/+ [-0.445366, 0.11867, -0.501579, -0.691207, 0.0411885, -0.62159, -0.311137,
    0.648751, 0.0521226, -0.595753] +/</font>
<u>sample</u>!(<font color=blue>float</font>, 3)(generate!<font color=blue>float</font>(-1f,1f));
<font color=green>// [0.942426, -0.182376, -0.223072]
</font></pre>
<br><br>

</dd>
<dt><big><a name="forAll"></a>DamnStat <u>forAll</u>(alias property, const(int) n = NUM_TESTS, alias reporter = null, Generators...)(lazy Generators <i>generators</i>) if (isCallable!property &amp;&amp; is(ReturnType!property == bool));
</big></dt>
<dd>Run a property based test
<br><br>
<b>Params:</b><br>
<table><tr><td>property</td>
<td>the property to test
                 needs to be callable and has return type a boolean</td></tr>
<tr><td>n</td>
<td>the number of tests to run (default is 100)</td></tr>
<tr><td>reporter</td>
<td>the reporter function that is used for manually "shrinking"
                 and reporting an error. It should be a function. It is passed
                 the failed arguments tuple and its return value is not used.</td></tr>
<tr><td>Generators generators</td>
<td>the function that generates input</td></tr>
</table><br>
<b>Returns:</b><br>
A tuple that contains whether all the tests passed or not (boolean), the
  number of tests to be ran (integer), the number of tests ran (integer) and
  the input (if any exists) at which the property failed (encoded as a string)

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>/+ Example without reporting +/</font>
<font color=blue>bool</font> idempotentSort(<font color=blue>int</font>[] list) {
    <font color=blue>return</font> list.sort == list.sort.sort;
}
DamnStat stat1 = <u>forAll</u>!property(generate!(<font color=blue>int</font>[]));
DamnStat stat2 = <u>forAll</u>!(property,1000)(generate!(<font color=blue>ulong</font>[]));
<font color=blue>if</font>(stat1[0] &amp;&amp; stat2[0]) {
    writef(<font color=red>"***** %d tests passed *****\n"</font>, stat1[1]);
} <font color=blue>else</font> {
    writef(<font color=red>"***** %d/%d tests passed *****\nError at input:\n%s"</font>,
           stat1[2], stat1[1], stat1[3]);
    writef(<font color=red>"***** %d/%d tests passed *****\nError at input:\n%s"</font>,
           stat2[2], stat2[1], stat2[3]);
}
</pre>
<pre class="d_code"><font color=green>/+ Example with reporting +/</font>
<font color=blue>bool</font> expandingFloat(<font color=blue>float</font> a, <font color=blue>float</font> b, <font color=blue>float</font> c) {
    <font color=blue>return</font> a * (b + c) == a * b + a * c;
}
<font color=blue>void</font> expandingFloatReporter(<font color=blue>float</font> a, <font color=blue>float</font> b, <font color=blue>float</font> c) {
    writeln(<font color=red>"Failed for: "</font>, a, <font color=red>" "</font>, b, <font color=red>" "</font>, c);
    writefln(<font color=red>"%.12f * (%.12f + %.12f) = %.12f"</font>, a, b, c, a*(b+c));
    writefln(<font color=red>"%.12f * %.12f + %.12f * %.12f = %.12f"</font>, a, b, a, c, a*b+a*c));
}

DamnStat stat = <u>forAll</u>!(expandingFloat, 100, expandingFloatShrinker)
                       (generate!<font color=blue>float</font>, generate!<font color=blue>float</font>, generate!<font color=blue>float</font>);
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
