<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>damncheck</title>
        </head><body>
        <h1>damncheck</h1>
        <!-- Generated by Ddoc from damncheck.d -->
DamnCheck - Property based testing library for D forked from dashcheck
<br><br>
<b>Authors:</b><br>
github.com/geezee

<br><br>
<b>Version:</b><br>
0.2

<br><br>
<b>License:</b><br>
MIT

<br><br>
<b>Forked:</b><br>
dashcheck - http://github.com/mcandre/dashcheck<br><br>

<dl><dt><big><a name="setGeneratorSeed"></a>void <u>setGeneratorSeed</u>(uint <i>seed</i> = unpredictableSeed);
</big></dt>
<dd>Set the <i>seed</i> of the random number generator used by the generators. If no
 <i>seed</i> was explicitly passed then it's unpredictable.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>seed</i></td>
<td>the <i>seed</i> of the random number generator (defaults to unpredictableSeed)</td></tr>
</table><br>
<b>See Also:</b><br>
oneOf, list, dict, choose, generate<br><br>

</dd>
<dt><big><a name="DamnStat"></a>struct <u>DamnStat</u>(T...);
</big></dt>
<dd>A report object that contains information about a test run
<br><br>
<b>See Also:</b><br>
forAll<br><br>

<dl><dt><big><a name="DamnStat.passed"></a>bool <u>passed</u>;
</big></dt>
<dd>Whether all the tests <u>passed</u> or not<br><br>

</dd>
<dt><big><a name="DamnStat.testNum"></a>size_t <u>testNum</u>;
</big></dt>
<dd>The number of tests scheduled to be ran<br><br>

</dd>
<dt><big><a name="DamnStat.testNumRan"></a>size_t <u>testNumRan</u>;
</big></dt>
<dd>The actual number of tets ran. If all the tests passed then this value
 is equal to testNum, otherwise it denotes how many tests ran before the
 bug showed up.<br><br>

</dd>
<dt><big><a name="DamnStat.seed"></a>uint <u>seed</u>;
</big></dt>
<dd>The <u>seed</u> used by the random number generator<br><br>

</dd>
<dt><big><a name="DamnStat.fail"></a>T <u>fail</u>;
</big></dt>
<dd>A tuple representing the arguments fed to the tested function. It is not
 defined if the tests ran successfully<br><br>

</dd>
<dt><big><a name="DamnStat.failStr"></a>@property string <u>failStr</u>();
</big></dt>
<dd>Property that produces a formatted string that represents the
 failing case. In case all the tests passed then this function returns
 <b>null</b><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ARRAY_MAX_SIZE"></a>int <u>ARRAY_MAX_SIZE</u>;
</big></dt>
<dd>The maximum size an (associative) array can have when generating a random
 one.
<br><br>
<b>See Also:</b><br>
list, dict<br><br>

</dd>
<dt><big><a name="NUM_TESTS"></a>int <u>NUM_TESTS</u>;
</big></dt>
<dd>The default number of tests to run
<br><br>
<b>See Also:</b><br>
forAll<br><br>

</dd>
<dt><big><a name="oneOf"></a>auto <u>oneOf</u>(T...)(lazy T <i>generators</i>) if (<i>generators</i>.length &gt;= 2);
</big></dt>
<dd>A meta-generator that selects randomly a provided generator from its input
 and returs the value it returns. Requires at least 2 inputs.
<br><br>
<b>Params:</b><br>
<table><tr><td>T generators</td>
<td>A tuple of generators</td></tr>
</table><br>
<b>Returns:</b><br>
the value that a random generator from the input returns

<br><br>
<b>Example:</b><br>
<pre class="d_code"><u>oneOf</u>(generate!<font color=blue>float</font>(-1f,1f), generate!<font color=blue>float</font>(99f,100f)); <font color=green>// a random number in [-1,1]U[99,100]
</font><u>oneOf</u>(2, 4, 0, 5, 10); <font color=green>// a random number in {2, 4, 0, 5, 10}
</font></pre>
<br><br>

</dd>
<dt><big><a name="mapGenerate"></a>U <u>mapGenerate</u>(alias mapper, T, U = T)(lazy T <i>generator</i> = generate!T);
</big></dt>
<dd>A meta-generator that applies a map on a generator to transform it into another
 generator.
<br><br>
<b>Params:</b><br>
<table><tr><td>mapper</td>
<td>the mapping function to use. It needs to be callable on one value.</td></tr>
<tr><td>T generator</td>
<td>the generator function to use when mapping</td></tr>
</table><br>
<b>Returns:</b><br>
An element from the generator that is mapped to the domain of the mapper

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>mapGenerate</u>!(a =&gt; a % 2 == 0 ? a + 1 : a)(generate!<font color=blue>int</font>); <font color=green>// generate an odd int
</font><u>mapGenerate</u>!(a =&gt; a % 10, <font color=blue>int</font>); <font color=green>// generate a number betwen -10 and 10
</font></pre>
<br><br>

</dd>
<dt><big><a name="list"></a>T[] <u>list</u>(T, size_t N = ARRAY_MAX_SIZE)(lazy T <i>generator</i> = generate!T);
</big></dt>
<dd>A meta-generator that builds an array of random length whose elements are
 generated from the provided generator.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>the maximum size the array can have (inclusive), the default
                value is ARRAY_MAX_SIZE</td></tr>
<tr><td>T generator</td>
<td>the generator to use to build the array, the default value is
                generate!T</td></tr>
</table><br>
<b>Returns:</b><br>
An array contaning some elements generated from the provided generator

<br><br>
<b>Throws:</b><br>
Exception when the generate!T generator is used if T is not a suitable
    type for generate.

<br><br>
<b>See Also:</b><br>
fixedList, generate, sample

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>list</u>!<font color=blue>int</font>; <font color=green>// generate a list of integers, [-12885020, .... 48124]
</font><u>list</u>!(<font color=blue>bool</font>,4); <font color=green>// generate a list that is at most 4 elements long, [true]
</font><u>list</u>!<font color=blue>int</font>(0); <font color=green>// generate an array of all 0s, [0, 0, ..., 0]
</font><u>list</u>!(<font color=blue>float</font>, 3)(generate!<font color=blue>float</font>(3, 5)); <font color=green>// [4.2852, 3.4924]
</font></pre>
<br><br>

</dd>
<dt><big><a name="fixedList"></a>T[] <u>fixedList</u>(T, size_t N)(lazy T <i>generator</i> = generate!T);
</big></dt>
<dd>A meta-generator that builds an array of length N whose elements are
 generated from the provided generator.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>the size of the array</td></tr>
<tr><td>T generator</td>
<td>the generator to use to build the array, the default
                value is generate!T</td></tr>
</table><br>
<b>Returns:</b><br>
An array contaning some elements generated from the provided generator

<br><br>
<b>Throws:</b><br>
Exception when the generate!T generator is used if T is not a suitable
    type for generate.

<br><br>
<b>See Also:</b><br>
list, generate, sample

<br><br>
<b>Examples:</b><br>
<pre class="d_code">list!(<font color=blue>int</font>, 5); <font color=green>// generate a list of integers of length 5, [4, 3, 2, 5, 6]
</font>list!(<font color=blue>int</font>, 3)(0); <font color=green>// generate an array of length 3 all 0s, [0, 0, 0]
</font>list!(<font color=blue>float</font>, 3)(generate!<font color=blue>float</font>(3, 5)); <font color=green>// [4.2852, 3.4924, 2.1035]
</font></pre>
<br><br>

</dd>
<dt><big><a name="dict"></a>T[U] <u>dict</u>(T, U, size_t N = ARRAY_MAX_SIZE)(lazy T <i>values</i> = generate!T, lazy U <i>keys</i> = generate!U);
</big></dt>
<dd>A meta-generator that builds an associative array whose length is random and
 whose keys and values are elements generated from the provided generators.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>the maximum length of the associative array (inclusive), the default
        is ARRAY_MAX_SIZE</td></tr>
<tr><td>T values</td>
<td>the generator to use to generate the values of the associative
             array, the default value is generate!T</td></tr>
<tr><td>U keys</td>
<td>the generator to use to generate the keys of the associative array,
           the default values is generate!U</td></tr>
</table><br>
<b>Returns:</b><br>
An associative array of random size and whose keys and values are generated
    from generators passed as arguments

<br><br>
<b>Throws:</b><br>
Exception if the key value and/or the value type force generate to throw
    an exception; i.e. when the types are not suitable for the generator

<br><br>
<b>See Also:</b><br>
generate

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>dict</u>!(<font color=blue>int</font>, <font color=blue>int</font>); <font color=green>// [-84: 92831, 8492: 4589284, -4892:-985717 ...]
</font><u>dict</u>!(<font color=blue>int</font>, <font color=blue>bool</font>); <font color=green>// [false: 21249894, true: -832194]
</font><u>dict</u>!(<font color=blue>int</font>, <font color=blue>bool</font>, 10000)(3); <font color=green>// [false: 3, true: 3]
</font></pre>
<br><br>

</dd>
<dt><big><a name="choose"></a>T <u>choose</u>(T)(T[] <i>array</i>);
</big></dt>
<dd>A generator that chooses randomly an element from a given array
<br><br>
<b>Params:</b><br>
<table><tr><td>T[] array</td>
<td>the array of elements to chose randomly from</td></tr>
</table><br>
<b>Returns:</b><br>
an element from the array that is chosen at random

<br><br>
<b>Throws:</b><br>
Exception if the input is of length 0

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>choose</u>([1, -1, 8, -8, 23]);
</pre>
<br><br>

</dd>
<dt><big><a name="generate"></a>T <u>generate</u>(T)(T <i>min</i> = T.init, T <i>max</i> = T.init);
</big></dt>
<dd>Generate some random values based on a type.
<br><br>
<b>Params:</b><br>
<table><tr><td>T min</td>
<td>only used for elements who have the init property and are not arrays.
         It is the smallest value an element can have (inclusive). The default
         is T.init which is then converted to T.min</td></tr>
<tr><td>T max</td>
<td>only used for elements who have the init property and are not arrays.
         It is the largest value an element can have (inclusive). The default
         is T.init which is then converted to T.max</td></tr>
</table><br>
<b>Returns:</b><br>
A random element of type T provided

<br><br>
<b>See Also:</b><br>
list, dict

<br><br>
<b>Throws:</b><br>
Exception when no generating function is available

<br><br>
<b>TODO:</b><br>
"Unwrap" a struct/class through the paramaters of their constructor and
   construct a random object through these types.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><u>generate</u>!<font color=blue>bool</font>; <font color=green>// true
</font><u>generate</u>!string; <font color=green>// "necxTT!30"
</font><u>generate</u>!(<font color=blue>int</font>[]); <font color=green>// will call list!int
</font><u>generate</u>!(<font color=blue>immutable</font> <font color=blue>int</font>[<font color=blue>char</font>[<font color=blue>immutable</font> <font color=blue>bool</font>]]);
<font color=green>// will call dict!(immutable int, char[immutable bool]);
</font>
<u>generate</u>!<font color=blue>int</font>(10); <font color=green>// 392874
</font><u>generate</u>!<font color=blue>float</font>(10f, 11f); <font color=green>// 10.7329
</font></pre>
<br><br>

</dd>
<dt><big><a name="sample"></a>T[] <u>sample</u>(T, const(int) N = 10)(lazy T <i>gen</i> = generate!T);
</big></dt>
<dd>Sampling some values that the generator produces. The <u>sample</u> function and the
 list function might seem very similar but besides the difference in the
 objective, this function returns exactly an array of size N while the list
 function returns a list that has at most size N.
<br><br>
<b>Params:</b><br>
<table><tr><td>T gen</td>
<td>the generator, defaults to generate!T where T is the generic type
         passed to the function</td></tr>
<tr><td>N</td>
<td>the number values to samples (default is 10)</td></tr>
</table><br>
<b>Returns:</b><br>
An array of size N containing samples from the generators

<br><br>
<b>Throws:</b><br>
Exception if the default generate!T generator is used with no suitable
   type.

<br><br>
<b>See Also:</b><br>
generate

<br><br>
<b>Example:</b><br>
<pre class="d_code"><u>sample</u>!<font color=blue>int</font>;
<font color=green>/+ [1541546906, -1397396910, 1173201093, 781288830, -10598603, -1822147006,
    1798781252, 950268125, -966182456, -275607635] +/</font>
<u>sample</u>!(<font color=blue>bool</font>, 2);
<font color=green>// [false, false]
</font><u>sample</u>(generate!<font color=blue>float</font>(-1f,1f));
<font color=green>/+ [-0.445366, 0.11867, -0.501579, -0.691207, 0.0411885, -0.62159, -0.311137,
    0.648751, 0.0521226, -0.595753] +/</font>
<u>sample</u>!(<font color=blue>float</font>, 3)(generate!<font color=blue>float</font>(-1f,1f));
<font color=green>// [0.942426, -0.182376, -0.223072]
</font></pre>
<br><br>

</dd>
<dt><big><a name="forAll"></a>DamnStat!(ParameterTypeTuple!property) <u>forAll</u>(alias property, const(int) n = NUM_TESTS, alias reporter = null, Generators...)(lazy Generators <i>generators</i>) if (isCallable!property &amp;&amp; is(ReturnType!property == bool));
</big></dt>
<dd>Run a property based test
<br><br>
<b>Params:</b><br>
<table><tr><td>property</td>
<td>the property to test
                 needs to be callable and has return type a boolean</td></tr>
<tr><td>n</td>
<td>the number of tests to run (default is 100)</td></tr>
<tr><td>reporter</td>
<td>the reporter function that is used for manually "shrinking"
                 and reporting an error. It should be a function. It is passed
                 the failed arguments tuple and its return value is not used.</td></tr>
<tr><td>Generators generators</td>
<td>the function that generates input</td></tr>
</table><br>
<b>Returns:</b><br>
A tuple that contains whether all the tests passed or not (boolean), the
  number of tests to be ran (integer), the number of tests ran (integer) and
  the input (if any exists) at which the property failed (encoded as a string)

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>/+ Example without reporting +/</font>
<font color=blue>bool</font> idempotentSort(<font color=blue>int</font>[] list) {
    <font color=blue>return</font> list.sort == list.sort.sort;
}
DamnStat stat1 = <u>forAll</u>!property(generate!(<font color=blue>int</font>[]));
DamnStat stat2 = <u>forAll</u>!(property,1000)(generate!(<font color=blue>ulong</font>[]));
<font color=blue>if</font>(stat1[0] &amp;&amp; stat2[0]) {
    writef(<font color=red>"***** %d tests passed *****\n"</font>, stat1[1]);
} <font color=blue>else</font> {
    writef(<font color=red>"***** %d/%d tests passed *****\nError at input:\n%s"</font>,
           stat1[2], stat1[1], stat1[3]);
    writef(<font color=red>"***** %d/%d tests passed *****\nError at input:\n%s"</font>,
           stat2[2], stat2[1], stat2[3]);
}
</pre>
<pre class="d_code"><font color=green>/+ Example with reporting +/</font>
<font color=blue>bool</font> expandingFloat(<font color=blue>float</font> a, <font color=blue>float</font> b, <font color=blue>float</font> c) {
    <font color=blue>return</font> a * (b + c) == a * b + a * c;
}
<font color=blue>void</font> expandingFloatReporter(<font color=blue>float</font> a, <font color=blue>float</font> b, <font color=blue>float</font> c) {
    writeln(<font color=red>"Failed for: "</font>, a, <font color=red>" "</font>, b, <font color=red>" "</font>, c);
    writefln(<font color=red>"%.12f * (%.12f + %.12f) = %.12f"</font>, a, b, c, a*(b+c));
    writefln(<font color=red>"%.12f * %.12f + %.12f * %.12f = %.12f"</font>, a, b, a, c, a*b+a*c));
}

DamnStat stat = <u>forAll</u>!(expandingFloat, 100, expandingFloatShrinker)
                       (generate!<font color=blue>float</font>, generate!<font color=blue>float</font>, generate!<font color=blue>float</font>);
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
